<!doctype html>
<html lang="nl">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Photeinos Springspel (web)</title>
  <style>
    html,body{height:100%;margin:0}
    body{display:flex;align-items:center;justify-content:center;background:#eef6ff;font-family:system-ui,-apple-system,Segoe UI,Roboto,Inter,Arial,sans-serif}
    .wrap{width:min(100vw,1100px);aspect-ratio:16/9;position:relative;border-radius:18px;overflow:hidden;box-shadow:0 10px 30px rgba(0,0,0,.12);background:#fff}
    canvas{display:block;width:100%;height:100%}
    .hud{position:absolute;left:12px;top:10px;background:rgba(255,255,255,.7);backdrop-filter:blur(4px);padding:8px 10px;border-radius:10px;font-size:14px;color:#1e3a8a}
    .start, .end, .modal{position:absolute;inset:0;display:grid;place-items:center}
    .card{background:#fff;color:#0f172a;border-radius:16px;box-shadow:0 10px 30px rgba(0,0,0,.2);padding:20px 22px;max-width:min(90%,560px);text-align:center}
    .title{font-weight:700;color:#1e40af;margin:6px 0 6px}
    .btn{appearance:none;border:0;border-radius:10px;background:#0ea5e9;color:#fff;padding:10px 14px;font-weight:600;cursor:pointer}
    .btn:active{transform:translateY(1px)}
    .ghost{background:#eff6ff;color:#1e40af}
    .answers{display:grid;gap:8px;margin-top:10px}
    .answers.two{grid-template-columns:repeat(2,minmax(0,1fr))}
    .answers .btn{background:#111827;color:#fff;border:1px solid #374151}
    .badge{display:inline-block;background:#ecfeff;color:#0c4a6e;border:1px solid #a5f3fc;border-radius:999px;padding:3px 8px;font-size:12px;margin:6px 0}
    .feedback{position:absolute;left:50%;top:12%;transform:translateX(-50%);background:rgba(255,255,255,.8);padding:8px 12px;border-radius:999px;color:#065f46;font-weight:700}
  </style>
</head>
<body>
  <div class="wrap" id="gameRoot">
    <canvas id="game"></canvas>

    <div class="hud" id="hud">Level 1/5 ‚Ä¢ Vleugels 0/0 ‚Ä¢ Score 0 ‚Ä¢ Totaal 0</div>
    <div class="feedback" id="feedback" style="display:none"></div>

    <div class="start" id="start">
      <div class="card">
        <div class="title">Photeinos Springspel</div>
        <div style="color:#334155;margin-bottom:10px">
          Tik/klik of druk <strong>spatie</strong> om te flappen (omhoog). Laat los om te dalen.<br/>
          Vang alle ü™Ω en ontwijk üíÄ. Na een ü™Ω krijg je een korte vraag.
        </div>
        <div class="badge">5 levels ‚Ä¢ van traag naar sneller</div>
        <div style="margin-top:12px;display:flex;gap:10px;justify-content:center">
          <button class="btn" id="startBtn">Start spel</button>
        </div>
      </div>
    </div>

    <div class="modal" id="question" style="display:none">
      <div class="card" id="qCard">
        <div id="qText" class="title" style="margin:0 0 10px"></div>
        <div id="qAnswers" class="answers"></div>
      </div>
    </div>

    <div class="end" id="end" style="display:none">
      <div class="card">
        <div class="title">Goed gespeeld!</div>
        <div id="endText" style="color:#14532d;margin:8px 0 12px"></div>
        <button class="btn" id="again">Speel opnieuw</button>
        <button class="btn ghost" id="back" style="margin-left:8px">Terug</button>
      </div>
    </div>
  </div>

<script>
(() => {
  // ================================
  // BEGIN: configuratie & helpers
  // ================================
  const cvs = document.getElementById('game');
  const ctx = cvs.getContext('2d');
  const hud = document.getElementById('hud');
  const startOverlay = document.getElementById('start');
  const endOverlay = document.getElementById('end');
  const endText = document.getElementById('endText');
  const feedback = document.getElementById('feedback');
  const startBtn = document.getElementById('startBtn');
  const againBtn = document.getElementById('again');
  const backBtn = document.getElementById('back');

  const qModal = document.getElementById('question');
  const qText  = document.getElementById('qText');
  const qAns   = document.getElementById('qAnswers');

  const rand = (a=0,b=1)=> a + Math.random()*(b-a);
  const clamp = (v,a,b)=> Math.max(a, Math.min(b, v));

  // levels: #wings en luchtkleur
  const LEVELS = [
    { wings: 10, sky: '#B3E5FC' },
    { wings: 10, sky: '#E6EE9C' },
    { wings: 10, sky: '#F8BBD0' },
    { wings: 10, sky: '#C5CAE9' },
    { wings: 10, sky: '#E1F5FE' },
  ];

  // catechetische vragen (demo ‚Äì vervang gerust)
  const LIGHT_QUESTIONS = [
    { q: "Iemand is verdrietig. Wat doe je?", opts:["Troosten","Uitlachen"], ok:0 },
    { q: "Voor het eten‚Ä¶", opts:["Bidden","Niets zeggen"], ok:0 },
    { q: "Je ziet rommel op straat. Wat doe je?", opts:["Oprapen","Laten liggen"], ok:0 },
    { q: "Een nieuw kind in de klas. Wat doe je?", opts:["Welkom heten","Negeren"], ok:0 },
    { q: "Gods naam gebruik je‚Ä¶", opts:["Met eerbied","Voor grapjes"], ok:0 },
  ];
  const SIN_QUESTIONS = [
    { q: "Iemand uitschelden mag dat?", ok:1 }, // antwoord: Nee = 1
    { q: "Pesten mag dat?", ok:1 },
    { q: "Stiekem iets nemen mag dat?", ok:1 },
    { q: "Is liegen goed?", ok:1 },
  ];

  // lanes (0..1; 1 = onderaan)
  function lanesForLevel(level){
    const L = Math.min(level, 4);
    switch(L){
      case 0: return { easy:[0.56,0.50], mix:[0.865] };
      case 1: return { easy:[0.58,0.50,0.44], mix:[0.84,0.78] };
      case 2: return { easy:[0.60,0.52,0.46], mix:[0.86,0.80,0.74,0.38] };
      case 3: return { easy:[0.62,0.54,0.48], mix:[0.88,0.84,0.78,0.72,0.36] };
      default:return { easy:[0.64,0.56,0.50], mix:[0.88,0.84,0.80,0.74,0.70,0.34] };
    }
  }
  const jitter = (base, j=0.016)=> clamp(base + rand(-j,j), 0.14, 0.98);
  const snapNearGrass = y => (y>0.90 ? 0.885 : y);

  function speedForLevel(level){ const base=0.0011, per=0.00038; return base + per*Math.min(level,6); }
  const skySpeed    = lvl => speedForLevel(lvl) * 0.45;
  const groundSpeed = lvl => speedForLevel(lvl) * 0.95;
  const playerXForLevel = lvl => clamp(0.44 + 0.035*lvl, 0.44, 0.58);

  // assets
  const playerImg = new Image();
  playerImg.src = "https://github.com/kathy-torfs/Orthodoxeweg/raw/main/images/photeinos_walk.png";

  // flowers glyphs
  const FLOWERS = ["üå∑","üåπ","üåª","üåº","üå∫","üå∏","üåæ","üåø","üçÄ","üå±"];

  // resize
  function fit(){
    const dpr = window.devicePixelRatio || 1;
    const rect = cvs.getBoundingClientRect();
    cvs.width  = rect.width * dpr;
    cvs.height = rect.height * dpr;
    ctx.setTransform(dpr,0,0,dpr,0,0); // schaal terug voor coords in CSS pixels
  }
  new ResizeObserver(fit).observe(cvs);
  fit();

  // ================================
  // EINDE configuratie & helpers
  // BEGIN: spel-state
  // ================================
  let started = false;
  let level = 0;
  let scoreLevel = 0;
  let scoreTotal = 0;

  let showQuestion = false;
  let awaitLastWing = false;

  // speler (flappy)
  let pY = 1.0, prevPY = 1.0, vY = 0;
  const gravity = 0.0092, flapImpulse = -0.10, maxUp=-0.16, maxDown=0.155;

  // achtergrond-actors
  let clouds = []; // {x,y,s}
  let flowers = []; // {x,y,s,g}
  // obstakels
  let obstacles = []; // {x,y,type,active}
  let wingsCaught = 0, wingsTarget = 0;

  // input
  let holding = false; // (optioneel voor continuous press‚Äînu flappy op ‚Äútap‚Äù)

  // ================================
  // helpers genereren
  // ================================
  function regenClouds(lvl){
    const r=[]; for(let i=0;i<6;i++) r.push({x:Math.random(), y:0.06+Math.random()*0.28, s:18+((Math.random()*16)|0)});
    return r;
  }
  function regenFlowers(lvl){
    const out=[]; const minDx=0.07;
    for(let i=0;i<90 && out.length<28;i++){
      const fx=Math.random(), fy=0.81+Math.random()*0.15, fs=12+((Math.random()*9)|0);
      const g=FLOWERS[(Math.random()*FLOWERS.length)|0];
      if(!out.some(o=>Math.abs(o.x-fx)<minDx && Math.abs(o.y-fy)<0.045)) out.push({x:fx,y:fy,s:fs,g});
    }
    return out;
  }

  function loadLevel(lvl){
    scoreLevel = 0;
    wingsCaught = 0;
    awaitLastWing = false;
    pY = 1.0; prevPY = 1.0; vY = 0;

    clouds  = regenClouds(lvl);
    flowers = regenFlowers(lvl);

    const lanes = lanesForLevel(lvl);
    const wingsNeeded = LEVELS[lvl].wings;
    wingsTarget = wingsNeeded;

    const total = wingsNeeded + Math.max(2, Math.floor(wingsNeeded * (0.55 + 0.1 * Math.min(lvl,4))));
    const minDelta = 0.22 - 0.02*Math.min(lvl,4);
    const lanesAll = [...lanes.easy, ...lanes.mix];
    const pLight = (lvl<=0?0.72:lvl===1?0.64:lvl===2?0.56:lvl===3?0.50:0.46);

    obstacles = [];
    let lastX = 1.10;
    let wingsInARow = 0;

    for(let i=0;i<total;i++){
      const forceSkull = wingsInARow>=2;
      const isLight = forceSkull ? false : Math.random()<pLight;
      wingsInARow = isLight? wingsInARow+1 : 0;

      const baseLane = (lvl<2)
        ? (isLight ? lanes.easy[(Math.random()*lanes.easy.length)|0] : lanes.mix[(Math.random()*lanes.mix.length)|0])
        : lanesAll[(Math.random()*lanesAll.length)|0];

      const y = snapNearGrass(jitter(baseLane));
      lastX += minDelta + Math.random()*0.10;

      obstacles.push({ x:lastX, y, type: isLight ? "light" : "skull", active:true });
    }
    // minimaal voldoende vleugels
    let have = obstacles.filter(o=>o.type==="light").length;
    for(let i=0;i<obstacles.length && have<wingsNeeded;i++){
      if(obstacles[i].type!=="light"){ obstacles[i].type="light"; have++; }
    }

    updateHud();
  }

  function startGame(){
    scoreTotal = 0;
    level = 0;
    started = true;
    endOverlay.style.display = 'none';
    startOverlay.style.display = 'none';
    loadLevel(0);
  }

  function nextLevel(){
    scoreTotal += scoreLevel;
    if(level + 1 < LEVELS.length){
      level += 1;
      loadLevel(level);
    } else {
      // klaar
      started = false;
      endText.textContent = `Je totale score: ${scoreTotal} lichtjes!`;
      endOverlay.style.display = 'grid';
    }
  }

  function updateHud(){
    hud.textContent = `Level ${level+1}/${LEVELS.length} ‚Ä¢ Vleugels ${wingsCaught}/${wingsTarget} ‚Ä¢ Score ${scoreLevel} ‚Ä¢ Totaal ${scoreTotal}`;
  }

  function showFeedback(text, ok=true){
    feedback.textContent = text;
    feedback.style.display = 'block';
    feedback.style.color = ok ? '#065f46' : '#7f1d1d';
    setTimeout(()=> feedback.style.display='none', 900);
  }

  // ================================
  // vragen (modal)
  // ================================
  function askLight(){
    const item = LIGHT_QUESTIONS[(Math.random()*LIGHT_QUESTIONS.length)|0];
    qText.textContent = item.q;
    qAns.className = 'answers';
    qAns.innerHTML = '';
    item.opts.forEach((o,idx)=>{
      const b = document.createElement('button');
      b.className = 'btn';
      b.textContent = o;
      b.onclick = () => {
        if(idx === item.ok){ scoreLevel++; showFeedback('Goed gedaan! +1', true); }
        else { showFeedback('Jammer! Niet juist.', false); }
        closeQuestion();
      };
      qAns.appendChild(b);
    });
    qModal.style.display = 'grid';
    showQuestion = true;
  }
  function askSin(){
    const item = SIN_QUESTIONS[(Math.random()*SIN_QUESTIONS.length)|0];
    qText.textContent = item.q;
    qAns.className = 'answers two';
    qAns.innerHTML = '';
    ['Ja','Nee'].forEach((o,idx)=>{
      const b = document.createElement('button');
      b.className = 'btn';
      b.textContent = o;
      b.onclick = () => {
        if(idx === item.ok){ // ok=1 (Nee)
          showFeedback('Juist! Dat mag niet.', true);
          closeQuestion();
        } else {
          // game over
          showFeedback('Helaas, dat was fout! Probeer opnieuw.', false);
          closeQuestion();
          started = false;
          endText.textContent = `Je totale score: ${scoreTotal} lichtjes!`;
          endOverlay.style.display = 'grid';
        }
      };
      qAns.appendChild(b);
    });
    qModal.style.display = 'grid';
    showQuestion = true;
  }
  function closeQuestion(){
    qModal.style.display = 'none';
    showQuestion = false;
    // als dit de laatste vleugel was: nu pas door
    if(!started) return;
    if(!showQuestion && awaitLastWing && wingsCaught >= wingsTarget){
      awaitLastWing = false;
      nextLevel();
    }
    updateHud();
  }

  // ================================
  // input
  // ================================
  function flap(){
    if(!started || showQuestion) return;
    vY = Math.max(maxUp, vY + flapImpulse);
  }
  window.addEventListener('keydown', e=>{
    if(e.code === 'Space'){ e.preventDefault(); flap(); }
  }, {passive:false});
  // klik/tap
  document.getElementById('gameRoot').addEventListener('mousedown', flap);
  document.getElementById('gameRoot').addEventListener('touchstart', e=>{ e.preventDefault(); flap(); }, {passive:false});

  startBtn.onclick = startGame;
  againBtn.onclick = startGame;
  backBtn.onclick = ()=>{ /* eventueel navigatie */ };

  // ================================
  // hoofdloop
  // ================================
  let last = performance.now();
  function loop(t){
    const dt = Math.min(40, t - last); last = t;

    // tekenen
    const W = cvs.clientWidth, H = cvs.clientHeight;
    // achtergrond lucht
    ctx.fillStyle = LEVELS[level]?.sky || '#B3E5FC';
    ctx.fillRect(0,0,W,H);

    if(started && !showQuestion){
      // fysica
      prevPY = pY;
      vY *= 0.985; vY += gravity; vY = clamp(vY, maxUp, maxDown);
      pY = clamp(pY + vY, 0.10, 1.00);

      // schuiven
      const dx = speedForLevel(level);
      // wolken
      for(const c of clouds){ c.x -= skySpeed(level); if(c.x < -0.10) c.x = 1.10; }
      // bloemen
      for(const f of flowers){ f.x -= groundSpeed(level); if(f.x < -0.05) f.x = 1.05; }
      // obstakels
      for(const o of obstacles){
        if(!o.active){ o.x = -1; continue; }
        o.x -= dx;
        if(o.x <= -0.10) o.x += 1.40; // wrap zodat gemist item later terugkomt
      }

      // botsingen
      const xCenter = playerXForLevel(level);
      const halfLight = 0.060, halfSkull = 0.038;
      const phY = clamp(pY + 0.032, 0, 1);
      const prevPhY = clamp(prevPY + 0.032, 0, 1);
      const segMin = Math.min(prevPhY, phY), segMax = Math.max(prevPhY, phY);

      for(let i=0;i<obstacles.length;i++){
        const o = obstacles[i]; if(!o.active) continue;
        const xMin = (o.type==='light' ? xCenter-halfLight : xCenter-halfSkull);
        const xMax = (o.type==='light' ? xCenter+halfLight : xCenter+halfSkull);
        const binnenX = o.x >= xMin && o.x <= xMax;
        const wingPad = (o.type==='light' && o.y>=0.84) ? 0.070 : 0.042;
        const skullPad = 0.030;
        const raak = (o.type==='light')
          ? (binnenX && (o.y >= segMin - wingPad && o.y <= segMax + wingPad))
          : (binnenX && (o.y >= segMin - skullPad && o.y <= segMax + skullPad));
        if(raak){
          o.active = false; o.x = -1;
          if(o.type === 'light'){
            wingsCaught++;
            const isLast = wingsCaught >= wingsTarget;
            awaitLastWing = isLast;
            askLight();
          } else {
            askSin();
          }
          break; // √©√©n per frame is voldoende
        }
      }

      // auto-next als alle vleugels en geen vraag open
      if(!showQuestion && !awaitLastWing && wingsCaught >= wingsTarget){
        nextLevel();
      }
      updateHud();
    }

    // Lucht/wolken
    ctx.save();
    ctx.textBaseline = 'alphabetic';
    for(const c of clouds){
      ctx.font = `${c.s}px serif`;
      ctx.fillText('‚òÅÔ∏è', c.x*W, c.y*H);
    }
    ctx.restore();

    // Gras
    const grassH = 0.22 * H;
    ctx.fillStyle = '#9CCC65';
    ctx.fillRect(0, H - grassH, W, grassH);

    // Bloemen
    ctx.save();
    for(const f of flowers){
      ctx.font = `${f.s}px serif`;
      ctx.fillText(f.g, f.x*W, f.y*H);
    }
    ctx.restore();

    // Obstakels
    ctx.save();
    ctx.font = `${H*0.08}px serif`;
    for(const o of obstacles){
      const emoji = o.type==='light' ? 'ü™Ω' : 'üíÄ';
      ctx.fillText(emoji, o.x*W, o.y*H);
    }
    ctx.restore();

    // Speler
    const px = playerXForLevel(level)*W, pyPix = (0.10 + 0.70*pY)*H;
    const size = H*0.20;
    if(playerImg.complete){
      ctx.drawImage(playerImg, px - size*0.5, pyPix - size*0.5, size, size);
    } else {
      ctx.save();
      ctx.fillStyle = '#1e293b';
      ctx.beginPath(); ctx.arc(px, pyPix, size*0.35, 0, Math.PI*2); ctx.fill();
      ctx.restore();
    }

    requestAnimationFrame(loop);
  }
  requestAnimationFrame(loop);

  // init overlays
  startOverlay.style.display = 'grid';
  endOverlay.style.display = 'none';
  updateHud();
})();
</script>
</body>
</html>
