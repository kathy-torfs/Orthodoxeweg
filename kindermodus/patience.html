<!DOCTYPE html>
<html lang="nl">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Patience / Solitaire â€“ Orthodoxe Kinderpagina</title> 
  <link rel="icon" href="images/kruis.png" />

  <style>
    :root{
      --primair:#7bb235; --donker:#67510C;
      --pastel1:#fff6e5; --pastel2:#fffde6; --pastel3:#ffe8ec; --pastel4:#e7f8ff;
      --pastel5:#e6ffe5; --pastel6:#fff2fb; --pastel7:#f5ffe5; --pastel8:#f5e8ff;
      --pastel9:#fff6fb; --pastel10:#e7fff9; --pastel11:#f3e6ff; --pastel12:#ffeae6;
      --pastel13:#ecffe9; --pastel14:#f7fff3; --pastel15:#eafffa; --pastel16:#fff4ea;
    }

    canvas {
      position: fixed;
      z-index: 10000;
      left: 0;
      top: 0;
      pointer-events: none;
    }

    #controls {
      width: 770px;
      margin: 10px auto;
      background-color: #3B96E5;
      box-sizing: border-box;
      padding: 6px;
      text-align: left;
    }
    #controls button {
      color: #fff;
      font-family: inherit;
      font-weight: 500;
      padding: 6px 12px;
      font-size: 16px;
      cursor: pointer;
      background-color: transparent;
      border: none;
    }
    #controls button:hover {
      background-color: rgba(0,0,0,0.3);
    }
    #score {
      color: #fff;
      float: right;
      padding: 6px 12px;
    }

    #spelcontainer {
      position: relative;
      height: 80vh;
      width: 770px;
      margin: 20px auto;
      text-align: center;
    }

    .columns { width: 100%; }
    .column {
      float: left;
      position: relative;
      width: 100px;
      height: 150px;
    }
    .pack, .dealt, .stack, .column {
      background-color: rgba(0,0,0,0.3);
      margin: 0 10px 10px 0;
      border-radius: 6px;
    }
    .stack {
      width: 100px;
      height: 150px;
      display: inline-block;
      position: relative;
    }
    .dealer, .stacks { float: left; }
    .dealer { width: 30%; text-align: left; }
    .stacks { width: 70%; text-align: right; }

    /* kaarten */
    .card {
      width: 100px;
      height: 150px;
      border: 2px solid #2c3e50;
      border-radius: 6px;
      position: absolute;
      background-color: #fff;
      cursor: pointer;
      transform: rotateY(180deg);
    }
    .card.flipped {
      box-shadow: 0 0 20px -5px #000;
      transform: rotateY(0deg);
    }
    .hearts, .diamonds { color:#c0392b; }
    .clubs, .spades { color:#2c3e50; }
    .hearts .value::after { content:"â™¥"; }
    .diamonds .value::after { content:"â™¦"; }
    .clubs .value::after { content:"â™£"; }
    .spades .value::after { content:"â™ "; }
  </style>

  <!-- Header + menubalk + beveiliging -->
  <script defer src="common/layout.js"></script>
</head>
<body>
  <!-- Header van de kindermodus -->
  <div id="kinder-header" data-header-src="common/header.html"></div>

  <!-- Controls en spelcontainer -->
  <div id="controls">
    <button type="button" data-action="undo">Ongedaan maken</button>
    <button type="button" data-action="hint">Hint</button>
    <button type="button" data-action="start">Herstart</button>
    <div id="score">Score: 0</div>
  </div>
  <div id="spelcontainer"></div>

  <script>
    // Zachte pastelachtergrond
    (function(){
      const p=['var(--pastel1)','var(--pastel2)','var(--pastel3)','var(--pastel4)','var(--pastel5)',
               'var(--pastel6)','var(--pastel7)','var(--pastel8)','var(--pastel9)','var(--pastel10)',
               'var(--pastel11)','var(--pastel12)','var(--pastel13)','var(--pastel14)',
               'var(--pastel15)','var(--pastel16)'];
      document.body.style.background = p[Math.floor(Math.random()*p.length)];
    })();

    // Header activeren
    (function boot(){
      if (!(window.KinderLayout)) return setTimeout(boot, 120);
      const el = document.getElementById('kinder-header');
      window.KinderLayout.mountHeader({
        rootId: 'kinder-header',
        headerSrc: el.dataset.headerSrc,
        active: 'spelletjes'
      });
    })();
  </script>
  <script>
  (function (global) {
    'use strict';
    var win = window,
        doc = document,
        body = doc.body;

    /* Object.assign polyfill */
    var extend = function (r, t) {
      for (var e = Object(r), n = 1; n < arguments.length; n++) {
        var a = arguments[n];
        if (null != a)
          for (var o in a)
            Object.prototype.hasOwnProperty.call(a, o) && (e[o] = a[o]);
      }
      return e;
    };

    /* Add event listener */
    var on = function (el, e, fn) {
      el.addEventListener(e, fn, false);
    };

    /* Iteration helper */
    var each = function (arr, fn, s) {
      if ("[object Object]" === Object.prototype.toString.call(arr)) {
        for (var d in arr)
          if (Object.prototype.hasOwnProperty.call(arr, d)) fn.call(s, d, arr[d]);
      } else {
        for (var e = 0, f = arr.length; e < f; e++) fn.call(s, e, arr[e]);
      }
    };

    /* Event emitter */
    var Emitter = function () {};
    Emitter.prototype = {
      on: function (event, fct) {
        this._events = this._events || {};
        this._events[event] = this._events[event] || [];
        this._events[event].push(fct);
      },
      off: function (event, fct) {
        this._events = this._events || {};
        if (event in this._events === false) return;
        this._events[event].splice(this._events[event].indexOf(fct), 1);
      },
      emit: function (event) {
        this._events = this._events || {};
        if (event in this._events === false) return;
        for (var i = 0; i < this._events[event].length; i++) {
          this._events[event][i].apply(
            this,
            Array.prototype.slice.call(arguments, 1)
          );
        }
      },
    };
    Emitter.mixin = function (obj) {
      var props = ["on", "off", "emit"];
      for (var i = 0; i < props.length; i++) {
        if (typeof obj === "function") {
          obj.prototype[props[i]] = Emitter.prototype[props[i]];
        } else {
          obj[props[i]] = Emitter.prototype[props[i]];
        }
      }
      return obj;
    };

    /* Vector */
    function Vector(x, y) {
      this.x = x;
      this.y = y;
    }
    Vector.prototype.add = function (v) {
      this.x += v.x;
      this.y += v.y;
    };

    /* Card */
    function Card(value, suit) {
      this.value = value;
      this.suit = suit;
      this.flipped = false;
      this.picture = this.value > 10;

      switch (this.suit) {
        case "hearts":
        case "diamonds":
          this.color = "red";
          break;
        case "clubs":
        case "spades":
          this.color = "black";
          break;
      }

      var cards = ["A", 2, 3, 4, 5, 6, 7, 8, 9, 10, "J", "Q", "K"];
      var template = [
        "<div class='front'><div class='value'>",
        cards[this.value - 1],
        "</div><div class='value'>",
        cards[this.value - 1],
        "</div><div class='middle'>",
      ];

      if (!this.picture) {
        for (var i = 0; i < this.value; i++) {
          template.push("<span></span>");
        }
      }
      template.push("</div></div><div class='rear'></div>");

      var card = doc.createElement("div");
      card.className = `card ${this.suit} card-${this.picture ? cards[this.value - 1] : this.value}`;
      card.innerHTML = template.join("");
      if (this.picture) {
        card.classList.add("picture");
      }
      card.card = true;
      this.el = card;
    }
    Card.prototype.flip = function () {
      this.el.classList.toggle("flipped", !this.flipped);
      this.el.draggable = !this.flipped;
      this.flipped = !this.flipped;
      if (!this.flipped) {
        this.el.style.transform = "";
      }
    };

    /* Pack */
    function Pack() {
      this.cards = [];
      this.suits = ["hearts", "spades", "diamonds", "clubs"];
      var count = 0;
      each(
        this.suits,
        function (i, suit) {
          for (var i = 1; i < 14; i++) {
            var card = new Card(i, suit);
            card.el.idx = count;
            this.cards.push(card);
            count++;
          }
        },
        this
      );
    }
    Pack.prototype.shuffle = function () {
      var m = this.cards.length,
        t,
        i;
      while (m) {
        i = Math.floor(Math.random() * m--);
        t = this.cards[m];
        this.cards[m] = this.cards[i];
        this.cards[i] = t;
        this.cards[i].el.idx = i;
        this.cards[m].el.idx = m;
      }
    };

    /* Game basis */
    function Game(el, options) {
      if (typeof el === "string") {
        el = document.querySelector(el);
      }
      this.el = el;
      this.options = extend({}, options);
      this.score = 0;
      this.animationInterval = 250;
      this.stackToColumn = false;
      this.history = [];
      this.pack = new Pack();
      Emitter.mixin(this);
      this.render();
    }
    Game.prototype.render = function () {
      var frag = document.createDocumentFragment();

      this.columns = doc.createElement("div");
      this.columns.className = "columns";

      this.stacks = doc.createElement("div");
      this.stacks.className = "stacks";

      /* create stacks */
      for (var i = 0; i < 4; i++) {
        var stack = doc.createElement("div");
        stack.className = "stack";
        this.stacks.appendChild(stack);
      }

      /* create columns */
      for (var i = 0; i < 7; i++) {
        var column = doc.createElement("div");
        column.className = "column";
        this.columns.appendChild(column);
      }

      this.dealer = doc.createElement("div");
      this.dealer.className = "dealer";

      this.packArea = doc.createElement("div");
      this.packArea.className = "pack";

      this.dealArea = doc.createElement("div");
      this.dealArea.className = "dealt";

      this.dealer.appendChild(this.packArea);
      this.dealer.appendChild(this.dealArea);

      frag.appendChild(this.dealer);
      frag.appendChild(this.stacks);
      frag.appendChild(this.columns);

      this.el.appendChild(frag);

      this.mouse = { x: 0, y: 0 };

      var id = "images/solitair-cards-{t}.png";
      this.images = {
        clubs: id.replace("{t}", "clubs"),
        spades: id.replace("{t}", "spades"),
        diamonds: id.replace("{t}", "diamonds"),
        hearts: id.replace("{t}", "hearts"),
      };

      each(
        this.images,
        function (i, src) {
          var image = new Image();
          image.onload = function () {};
          image.src = src;
          this.images[i] = image;
        },
        this
      );

      this.events = {
        click: this.click.bind(this),
        mousedown: this.mousedown.bind(this),
        keydown: this.keydown.bind(this),
        mouseup: this.mouseup.bind(this),
        dragstart: this.dragstart.bind(this),
        dragenter: this.dragenter.bind(this),
        dragover: this.dragover.bind(this),
        dragend: this.dragend.bind(this),
      };

      on(this.dealer, "click", this.events.click);
      on(this.el, "mousedown", this.events.mousedown);
      on(doc, "keydown", this.events.keydown);
      on(doc, "mouseup", this.events.mouseup);
      on(doc, "dragstart", this.events.dragstart);
      on(doc, "dragenter", this.events.dragenter);
      on(doc, "dragover", this.events.dragover);
      on(doc, "dragend", this.events.dragend);
    };

    Game.prototype.click = function (e) {
      var t = e.target;
      if (t.classList.contains("pack")) {
        e.stopImmediatePropagation();
        this.deal();
      }
    };

    Game.prototype.keydown = function (e) {
      var k = e.key;
      if (e.ctrlKey) {
        switch (k) {
          case "z":
            this.undo();
            break;
        }
      }
    };

    Game.prototype.mousedown = function (e) {
      var t = e.target.closest(".card");

      if (t && t.card) {
        this.siblings = [];
        var card = this.pack.cards[t.idx];
        var next = card.el.nextElementSibling;

        card.checked = false;

        card.origin = {
          x: e.pageX,
          y: e.pageY,
        };

        card.el.classList.add("dragging");
        this.activeCard = card;
        this.startParent = card.el.parentNode;

        // grab the cards on top as well
        if (next) {
          var p = next.parentNode;
          var idx = Array.from(p.children).indexOf(next);
          for (var i = idx; i < p.childElementCount; i++) {
            var c = p.children[i];
            c.classList.add("dragging");
            this.siblings.push(c);
          }
        }
      }
    };

    Game.prototype.dragstart = function (e) {
      e.dataTransfer.effectAllowed = "copy";
      e.dataTransfer.setData("text/html", "");

      // Create blank image to hide the ghost
      var dragIcon = doc.createElement("img");
      e.dataTransfer.setDragImage(dragIcon, -10, -10);

      this.dragging = true;
    };

    Game.prototype.dragenter = function (e) {
      var t = e.target;
      var column = t.classList.contains("column");
      var stack = t.classList.contains("stack");
      var canDrop = t.card || column || stack;

      if (this.activeColumn) {
        this.activeColumn.classList.remove("over");
      }

      if (canDrop) {
        if (column || stack) {
          this.activeColumn = t;
        } else {
          this.activeColumn = t.parentNode;
        }
        this.activeColumn.classList.add("over");
      }
    };

    Game.prototype.dragover = function (e) {
      e.preventDefault();
      e.dataTransfer.dropEffect = "over";

      // Physically drag the card instead of using the D&D ghost
      if (this.activeCard && this.dragging) {
        var c = this.activeCard;
        var x = e.pageX - c.origin.x;
        var y = e.pageY - c.origin.y;
        var css =
          "pointer-events: none; transform: scale(1.05, 1.05) rotateX(0deg) translate3d(" +
          x +
          "px, " +
          y +
          "px, 0px);";

        this.activeCard.el.style.cssText = css;

        if (this.siblings.length) {
          each(
            this.siblings,
            function (i, card) {
              card.style.cssText = css;
            },
            this
          );
        }
      }
    };

    Game.prototype.dragend = function (e) {
      if (this.activeCard && this.dragging) {
        var c = this.activeCard;
        c.el.classList.remove("dragging");

        var x = e.pageX - c.origin.x;
        var y = e.pageY - c.origin.y;

        c.el.style.cssText = "";

        if (this.siblings.length) {
          each(
            this.siblings,
            function (i, card) {
              card.classList.remove("dragging");
              card.style.cssText = "";
            },
            this
          );
        }

        if (this.activeColumn) {
          this.activeColumn.classList.remove("over");
        }

        if (this.isLegalMove()) {
          var prev = c.el.previousElementSibling;

          // Flip the last card
          if (prev) {
            var card = this.pack.cards[prev.idx];
            if (!card.flipped) {
              card.prevState = card.flipped;
              card.flip();
              this.score += 5;
            }
          }

          this.stackToColumn = c.el.parentNode.classList.contains("stack");

          this.pickCount = c.el.parentNode.childElementCount;
          this.dropCount = this.activeColumn.childElementCount;

          this.activeColumn.appendChild(c.el);
          this.updateScore();

          if (this.siblings.length) {
            each(
              this.siblings,
              function (i, card) {
                if (
                  this.activeCard.value === 13 &&
                  this.dropCount === 0 &&
                  !this.startParent.classList.contains("dealt") &&
                  c.el.parentNode.firstElementChild === c.el
                ) {
                  // geen extra score voor koning-move
                } else {
                  this.score += 5;
                }
                c.el.parentNode.appendChild(card);
                card.classList.remove("dragging");
              },
              this
            );
          }

          this.updateHistory();
          this.startParent.classList.toggle(
            "empty",
            !this.startParent.childElementCount
          );
          this.activeColumn.classList.toggle(
            "empty",
            !this.activeColumn.childElementCount
          );

          this.emit("change");
        }
      }

      if (!this.stackToColumn) {
        this.check();
      }
    };

    Game.prototype.mouseup = function (e) {
      if (this.activeCard) {
        this.activeCard.el.classList.remove("dragging");
        this.activeCard = false;

        if (this.siblings.length) {
          each(
            this.siblings,
            function (i, card) {
              card.classList.remove("dragging");
            },
            this
          );
        }
      }
      this.hinted = false;
      this.emit("change");
    };
    Game.prototype.updateHistory = function (
      card,
      start,
      end,
      siblings
    ) {
      var obj = {};

      if (Array.isArray(card)) {
        obj.deal = true;
      } else {
        card = card || this.activeCard;
        start = start || this.startParent;
        end = end || this.activeColumn;
        siblings = siblings || this.siblings;

        // Max moves to store
        var max = 10;
        var cards = this.pack.cards;
        var prev = card.el.previousElementSibling;

        obj = {
          card: card,
          start: start,
          end: end,
          siblings: siblings,
        };

        if (prev) {
          obj.prevSibling = {
            card: cards[prev.idx],
            flipped: cards[prev.idx].flipped,
          };
        }
      }

      this.history.push(obj);

      if (this.history.length > max) {
        this.history.splice(0, this.history.length - max);
      }
    };

    Game.prototype.updateScore = function (start, stop) {
      start = start || this.startParent;
      stop = stop || this.activeColumn;

      // Moving Kings from empty column to empty column
      if (
        this.dropCount === 0 &&
        this.activeCard.value === 13 &&
        !start.classList.contains("dealt") &&
        this.activeCard.el.parentNode.firstElementChild === this.activeCard.el
      ) {
        return false;
      }

      // Moving from deck to column
      if (start.classList.contains("dealt")) {
        if (stop.classList.contains("column")) {
          this.score += 5;
        }
      } else if (start.classList.contains("column")) {
        if (stop.classList.contains("column")) {
          this.score += 3;
        }
      }

      // Moving to suit stack
      if (stop.classList.contains("stack")) {
        this.score += 10;
      }

      // Moving from stacks to columns
      if (start.classList.contains("stack") && stop.classList.contains("column")) {
        this.score -= 10;
      }
    };

    Game.prototype.isLegalMove = function (active, column) {
      active = active || this.activeCard;
      column = column || this.activeColumn;

      var last = false;
      var legalMove = false;

      var lastEl = column.lastElementChild;
      var isColumn = column.classList.contains("column");
      var isPlaceholder = column.classList.contains("stack");

      if (lastEl) {
        last = this.pack.cards[lastEl.idx];
      }

      if (isColumn) {
        if (!column.childElementCount) {
          legalMove = active.value === 13;
        } else {
          legalMove =
            active.color !== last.color && active.value === last.value - 1;
        }
      } else if (isPlaceholder) {
        if (!column.childElementCount) {
          legalMove = active.value === 1;
        } else {
          legalMove =
            active.color === last.color &&
            active.suit === last.suit &&
            active.value === last.value + 1;
        }
      }
      return legalMove;
    };

    Game.prototype.undo = function () {
      var move = this.history.pop();
      if (!move) return;

      if (move.deal) {
        // undo last deal
        var cards = this.dealArea.querySelectorAll(".card");
        if (cards.length) {
          var last = cards[cards.length - 1];
          this.packArea.appendChild(last);
          var card = this.pack.cards[last.idx];
          card.flip();
        }
      } else {
        // move card(s) back
        move.start.appendChild(move.card.el);
        if (move.siblings.length) {
          each(move.siblings, function (i, card) {
            move.start.appendChild(card);
          });
        }
        if (move.prevSibling) {
          if (move.prevSibling.flipped !== this.pack.cards[move.prevSibling.card.el.idx].flipped) {
            this.pack.cards[move.prevSibling.card.el.idx].flip();
          }
        }
      }
      this.emit("change");
    };

    Game.prototype.deal = function () {
      // aangepast: 1 kaart draaien i.p.v. 3
      var card = this.packArea.lastElementChild;
      if (card) {
        this.dealArea.appendChild(card);
        var c = this.pack.cards[card.idx];
        if (!c.flipped) {
          c.flip();
        }
        this.updateHistory([c]);
        this.score -= 1;
        this.emit("change");
      } else {
        // recycle de dealArea terug naar packArea
        var cards = this.dealArea.querySelectorAll(".card");
        for (var i = cards.length - 1; i >= 0; i--) {
          this.packArea.appendChild(cards[i]);
          this.pack.cards[cards[i].idx].flip();
        }
      }
    };
    Game.prototype.check = function () {
      var stacks = this.stacks.querySelectorAll(".stack");
      var complete = 0;
      each(
        stacks,
        function (i, stack) {
          if (stack.childElementCount === 13) {
            complete++;
          }
        },
        this
      );
      if (complete === 4) {
        this.win();
      }
    };

    Game.prototype.start = function () {
      this.reset();
      this.pack.shuffle();

      // deel naar kolommen
      var columns = this.columns.querySelectorAll(".column");
      var count = 0;
      for (var i = 0; i < columns.length; i++) {
        for (var j = 0; j <= i; j++) {
          var card = this.pack.cards[count++];
          columns[i].appendChild(card.el);
          if (j === i) {
            card.flip();
          }
        }
      }

      // rest in de packArea
      for (; count < this.pack.cards.length; count++) {
        this.packArea.appendChild(this.pack.cards[count].el);
      }

      this.score = 0;
      this.history = [];
      this.emit("start");
    };

    Game.prototype.hint = function () {
      if (this.hinted) return;
      var all = this.el.querySelectorAll(".card.flipped");
      for (var i = 0; i < all.length; i++) {
        var c = this.pack.cards[all[i].idx];
        var cols = this.columns.querySelectorAll(".column, .stack");
        for (var j = 0; j < cols.length; j++) {
          if (this.isLegalMove(c, cols[j])) {
            all[i].classList.add("hint");
            setTimeout(function (card) {
              card.classList.remove("hint");
            }, 1500, all[i]);
            this.hinted = true;
            return;
          }
        }
      }
    };

    Game.prototype.reset = function () {
      this.el.innerHTML = "";
      this.render();
    };

    Game.prototype.win = function () {
      alert("Proficiat! Je hebt gewonnen ðŸŽ‰");
      this.emit("win");
    };

    Game.prototype.cheat = function () {
      // alle kaarten in volgorde op stacks zetten
      var suits = ["hearts", "spades", "diamonds", "clubs"];
      for (var i = 0; i < suits.length; i++) {
        var stack = this.stacks.children[i];
        for (var j = 1; j <= 13; j++) {
          var card = new Card(j, suits[i]);
          card.flip();
          stack.appendChild(card.el);
        }
      }
      this.win();
    };

    // Game initialisatie
    global.Game = Game;

  })(this);

  // init controls en spel starten
  var controls = document.getElementById("controls"),
      score = document.getElementById("score"),
      game = new Game("#spelcontainer");

  game.on("start", function () {
    score.textContent = "Score: " + this.score;
  });
  game.on("change", function () {
    score.textContent = "Score: " + this.score;
  });

  controls.addEventListener("click", function (e) {
    var t = e.target;
    if (t.nodeName === "BUTTON") {
      var action = t.getAttribute("data-action");
      if (typeof game[action] === "function") {
        game[action]();
      }
    }
  });

  // automatisch starten
  game.start();
  </script>
</body>
</html>
